<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <title>raw</title>
  <script src="../raw.js"></script>
  <script src="demo.js"></script>
</head>

<body>
  <script>        
    demo({}, function (app, renderer, camera) {
      
      var ter = app.create_entity({
        components: {
          'transform': {},
          'terrain': {
            wireframe: true,
            shaded:true,
            region_size: 1024,
            terrain_quality: 4,
            quality_distance: 2000,
            draw_distance: 6000,
            detail_levels: [1,4, 8, 12,16,22],
            region_distance: 8,
            regions_from_image_url: [
              ["res/heightmap10.jpg", -6, -6, 0.25, 2048, 2048, 8]
            ],
            material: {
              texture_tiles: [
                "res/dirt.jpg",
                "res/grass.jpg",
                "res/mud.jpg",
                "res/stone.jpg"
              ],
              normal_tiles: [
                "res/nm8.jpg",
                "res/nm9.jpg",
                "res/nm10.jpg",
                "res/nm11.jpg"
              ],
              shader:`
vec4 mix_texture_tiles(vec4 tile1,vec4 tile2,vec4 tile3,vec4 tile4,vec3 normal){
	return mix(tile1,mix(read_tile(u_texture_tiles_rw,4.0, 1.0,0.0), tile3,0.5),abs(normal.x));
}
void fragment(void){
  super_fragment();
}
`


            },
            skybox: {
              sun_direction: app.default_light.transform_controller.fw_vector
            }

          }
        }
      });
      console.log(ter);     

      // update terrain system 15 times in one sec
      app.systems.terrain_system.step_size = 1/30;
      app.update_debug_canvas = function (ctx) {
        ctx.fillText('Terrain '+ ter.terrain.debug_text, 3, 500);

      };

      var ca = 0;
      app.begin_loop(function (delta) {

        camera.transform.position[0] = -Math.sin(ca * raw.math.DEGTORAD) * 4096;
        camera.transform.position[2] = Math.cos(ca * raw.math.DEGTORAD) * 4096;
        camera.transform_controller.move_front_back(
          Math.cos(ca * raw.math.DEGTORAD) *
          (Math.random()*1));
        camera.transform_controller.yaw_pitch(0,
           Math.sin(ca * raw.math.DEGTORAD) * 0.002);
        camera.transform.require_update = 1;

        app.default_light.transform_controller.rotate_eular(
          -Math.sin((ca % 180) * raw.math.DEGTORAD) *0.5
          , 160 * raw.math.DEGTORAD, 0);

        ca += 0.025;
        ca = ca % 360;






        if (camera.transform.require_update !== 0) {
          if (camera.transform.position[1] < ter.terrain.height_on_camera + 50) {
            camera.transform.position[1] = ter.terrain.height_on_camera + 50;
          }
        }
        app.tick_debug(delta);
        

      }, 1 / 90);

      
    });

  </script>
</body>
</html>